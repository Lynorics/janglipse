/*
 * Copyright 2013
 *
 * Licensed under the Eclipse Public License version 1.0, available at
 * http://opensource.org/licenses/eclipse-1.0.txt
 */
grammar de.lynorics.eclipse.jangaroo.AS3 with org.eclipse.xtext.common.Terminals 

generate aS3 "http://www.lynorics.de/eclipse/jangaroo/AS3"

Model hidden(WS, ML_COMMENT, SL_COMMENT):
  package=Package
  |
  imp=Imports
  classes+=(Class|Interface)*;

Package:
  'package' name=QualifiedName '{' 
  imp=Imports
  directives+=directive*
  classes+=(Class|Interface)*
  '}';

Imports: {Imports}
  imports+=Import*
;
Import:
    'import' importedNamespace = QualifiedNameWithWildcard ';'
;

directive: {directive}
    "[" name=ID ("(" annonFields=annotationFields ")")? "]"
  | Uses
  | ";";

Uses:
	"use" name=ID (type=QualifiedName|'*'|'void')
  ;
  
annotationFields :
    anoonFields+=annotationField ("," annonFields+=annotationField)*;

annotationField :
    name=ID "=" expr=Expression;

QualifiedNameWithWildcard:
    QualifiedName '.*'?
;

QualifiedName:
  ID ('.' ID)*
;

Interface:
   access=AccessLevel? 'interface' name=ID
   ('extends' superclass=[Interface|QualifiedName])?
   '{' members += Member* '}'
;
Class:
   access=AccessLevel? 'final'? 'static'? 'dynamic'? 'class' name=ID
   ('extends' superType=[Class|QualifiedName])?
   ('implements' types+=[Interface|QualifiedName] (',' types+=[Interface|QualifiedName])*)?
   '{' members += Member* '}'
   ;

Member: 
    var=VariableDeclaration 
  | meth=Method
;

Method:
  'override'? access=AccessLevel? 'native'? 'static'? 'function' ('get'|'set')? name=ID
  '(' (params+=Parameter (',' params+=Parameter)*)? ')' 
  (':' ('void'|type=[Class|QualifiedName]))?
  body=MethodBody
;

enum AccessLevel:
  PRIVATE='private' | PUBLIC='public' | PROTECTED='protected' | INTERNAL='internal' ;

MethodBody: 
  {MethodBody} '{' statements += Statement* '}';

Statement:
  VariableDeclaration |
  Return |
  Expression ';' |
  IfStatement |
  SwitchStatement |
  TryStatement |
  WhileStatement |
  DoWhileStatement |
  ForStatement |
  NewStatement |
  objectLiteral
;

NewStatement:
	{New} 'new' type=[Class|QualifiedName]
	('(' param=Parameters? ')')?
;

ForStatement:
  'for' '(' forinit=commaExpr? ';'
    condition=commaExpr? ';' iterator=commaExpr? ')' command=StatementsBlock
  | 'for' '(' 'var'
    elements+=identifierDeclaration
    (',' elements+=identifierDeclaration)* ';' 
    condition=commaExpr? ';' iterator=commaExpr? ')' command=StatementsBlock
  | 'for' 'each'? '(' nameForin=ID 'in' forinexpr=Expression ')' forcommand=StatementsBlock
  | 'for' 'each'? '(' 'var' nameForeachh=ID relation=typeRelation?
    'in' foreachexpr=Expression ')' foreachcommand=StatementsBlock
;

identifierDeclaration :
    name=ID relation=typeRelation? ('=' expr=exprOrObjectLiteral)?;

commaExpr :
    elements+=Expression
    (',' elements+=Expression)*;
    
DoWhileStatement:
  {While} 'do'
  whileBlock=StatementsBlock
  'while'
  cond=parenthesizedExpr ';'
;

WhileStatement:
	{While} 'while' cond=parenthesizedExpr
	whileBlock=StatementsBlock
;

SwitchStatement:
	{Switch} 'switch' cond=parenthesizedExpr
	'{' cases+=statementInSwitch* '}'
;

parenthesizedExpr :
    '(' expression=exprOrObjectLiteral ')';
    
statementInSwitch :
   Statement
  | 'case' Expression ':'
  | 'default' ':';

Return:
  'return' expression=Expression ';'
;

VariableDeclaration:
  access=AccessLevel? 'static'? 'var' name=ID ':' type=VarType ('=' expression=Expression)? ';'
;

VarType:
	  'void'
	| '*'
	| type=[Class|QualifiedName]
;

IfStatement:
  'if' '(' expression=Expression ')' thenBlock=IfBlock
  (=>'else' elseBlock=IfBlock)?
;

TryStatement:
  'try' '{' statements += Statement+ '}'
  ('catch' '(' params+=Parameter')')?
  ('finally' finallyBlock=StatementsBlock)?
;

IfBlock:
  statements += Statement
  | StatementsBlock
;

StatementsBlock:
	'{' statements += Statement* '}'
;

Block:
  MethodBody | IfBlock
;

Parameter :
    'const'? name=ID rel=typeRelation? ('=' lit=exprOrObjectLiteral)?;

Parameters :
  (elements+=Parameter
  (',' elements+=Parameter)*)?
  | 
  (elements+=Parameter
  (',' elements+=Parameter)* ',')?
  name=ID rel=typeRelation?;

typeRelation :
    ':' ('void' | type=[Class|QualifiedName]);
    
objectLiteral :
    '{' objectFields '}';

objectFields :
    fields+=objectField
    (',' fields+=objectField)*;

objectField :
    ID ':' exprOrObjectLiteral
  | STRING ':' exprOrObjectLiteral
  | INT ':' exprOrObjectLiteral;

exprOrObjectLiteral :
    Expression
  | objectLiteral
  ;

Symbol:
  VariableDeclaration | Parameter
;

Expression:
  Assignment
;

Assignment returns Expression:
  SelectionExpression 
  ({Assignment.left=current} '=' right=Expression)?
;

SelectionExpression returns Expression:
  TerminalExpression 
  (
    {MemberSelection.receiver=current} '.' 
    member=[Member]
    (methodinvocation?='(' 
      (args+=Expression (',' args+=Expression)*)? ')' )?
  )*
;

TerminalExpression returns Expression:
   {StringConstant} value=STRING |
   {IntConstant} value=INT |
   {BoolConstant} value = ('true' | 'false') |
   {This} 'this' |
   {Super} 'super' |
   {Null} 'null' |
   {Undefined} 'undefined' |
   {SymbolRef} symbol=[Symbol] |
   {TerminalOp} TerminalOperator |
   '(' Expression ')'; 

TerminalOperator:
    '='
  | '*='
  | '/='
  | '%='
  | '+='
  | '-='
  | '<<='
  | '>>='
  | '>>>='
  | '&='
  | '^='
  | '|='
  | '?:'
  | '||'
  | '&&'
  | '|'
  | '^'
  | '&'
  | '=='
  | '!='
  | '==='
  | '!=='
  | '<'
  | '>'
  | '<='
  | '>='
  | 'as'
  | 'in'
  | 'instanceof'
  | 'is'
  | '<<'
  | '>>'
  | '>>>'
  | '+'
  | '-'
  | '*'
  | '/'
  | '%'
  | '++'
  | '--'
  | '!'
  | '~'
  | 'typeof'
  | '.'
  | '::'
  | '?'
  | ':'
;