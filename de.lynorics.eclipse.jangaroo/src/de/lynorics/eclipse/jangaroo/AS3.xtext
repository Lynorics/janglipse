/*
 * Copyright 2013
 *
 * Licensed under the Eclipse Public License version 1.0, available at
 * http://opensource.org/licenses/eclipse-1.0.txt
 */
grammar de.lynorics.eclipse.jangaroo.AS3 with org.eclipse.xtext.common.Terminals 

generate aS3 "http://www.lynorics.de/eclipse/jangaroo/AS3"

Model hidden(WS, ML_COMMENT, SL_COMMENT):
  Package
  |
  imports+=Import*
  classes+=Class*;

Package:
  'package' name=QualifiedName '{' 
  imports+=Import*
  classes+=(Class|Interface)*
  '}';

Import:
    'import' importedNamespace = QualifiedNameWithWildcard ';'
;

QualifiedNameWithWildcard:
    QualifiedName '.*'?
;

QualifiedName:
  ID ('.' ID)*
;

Interface returns Class:
   access=AccessLevel? 'interface' name=ID
   ('extends' superclass=[Class|QualifiedName])?
   '{' members += Member* '}'
;
Class:
   access=AccessLevel? 'static'? 'class' name=ID
   ('extends' superclass=[Class|QualifiedName])?
   ('implements' types+=[Class|QualifiedName] (',' types+=[Class|QualifiedName])*)?
   '{' members += Member* '}'
   ;

Member: 
    var=VariableDeclaration 
  | meth=Method
;

Method:
  access=AccessLevel? 'static'? 'function' ('get'|'set')? name=ID
    '(' (params+=Parameter (',' params+=Parameter)*)? ')' 
    (':' type=[Class|QualifiedName])?
    body=MethodBody
;

enum AccessLevel:
  PRIVATE='private' | PUBLIC='public' | PROTECTED='protected';

MethodBody: 
  {MethodBody} '{' statements += Statement* '}';

Statement:
  VariableDeclaration |
  Return |
  Expression ';' |
  IfStatement |
  SwitchStatement |
  TryStatement |
  WhileStatement |
  DoWhileStatement |
  ForStatement |
  NewStatement |
  objectLiteral
;

NewStatement:
	{New} 'new' type=[Class|QualifiedName]
	('(' param=Parameters ')')?
;

ForStatement:
  'for' '(' forinit=commaExpr? ';'
    condition=commaExpr? ';' iterator=commaExpr? ')' command=StatementsBlock
  | 'for' '(' 'var'
    elements+=identifierDeclaration
    (',' elements+=identifierDeclaration)* ';' 
    condition=commaExpr? ';' iterator=commaExpr? ')' command=StatementsBlock
  | 'for' 'each'? '(' nameForin=ID 'in' forinexpr=Expression ')' forcommand=StatementsBlock
  | 'for' 'each'? '(' 'var' nameForeachh=ID relation=typeRelation?
    'in' foreachexpr=Expression ')' foreachcommand=StatementsBlock
;

identifierDeclaration :
    name=ID relation=typeRelation? ('=' expr=exprOrObjectLiteral)?;

commaExpr :
    elements+=Expression
    (',' elements+=Expression)*;
    
DoWhileStatement:
  {While} 'do'
  whileBlock=StatementsBlock
  'while'
  cond=parenthesizedExpr ';'
;

WhileStatement:
	{While} 'while' cond=parenthesizedExpr
	whileBlock=StatementsBlock
;

SwitchStatement:
	{Switch} 'switch' cond=parenthesizedExpr
	'{' cases+=statementInSwitch* '}'
;

parenthesizedExpr :
    '(' expression=exprOrObjectLiteral ')';
    
statementInSwitch :
   Statement
  | 'case' Expression ':'
  | 'default' ':';

Return:
  'return' expression=Expression ';'
;

VariableDeclaration:
  'var' name=ID ':' type=[Class|QualifiedName] ('=' expression=Expression)? ';'
;

IfStatement:
  'if' '(' expression=Expression ')' thenBlock=IfBlock
  (=>'else' elseBlock=IfBlock)?
;

TryStatement:
  'try' '{' statements += Statement+ '}'
  ('catch' '(' params+=Parameter')')?
  ('finally' finallyBlock=StatementsBlock)?
;

IfBlock:
  statements += Statement
  | StatementsBlock
;

StatementsBlock:
	'{' statements += Statement* '}'
;

Block:
  MethodBody | IfBlock
;

Parameter :
    'const'? name=ID rel=typeRelation? ('=' lit=exprOrObjectLiteral)?;

Parameters :
  (elements+=Parameter
  (',' elements+=Parameter)*)?
  | 
  (elements+=Parameter
  (',' elements+=Parameter)* ',')?
  name=ID rel=typeRelation?;

typeRelation :
    ':' type=[Class|QualifiedName];
    
objectLiteral :
    '{' objectFields '}';

objectFields :
    fields+=objectField
    (',' fields+=objectField)*;

objectField :
    ID ':' exprOrObjectLiteral
  | STRING ':' exprOrObjectLiteral
  | INT ':' exprOrObjectLiteral;

exprOrObjectLiteral :
    Expression
  | objectLiteral
  ;

Symbol:
  VariableDeclaration | Parameter
;

Expression:
  Assignment
;

Assignment returns Expression:
  SelectionExpression 
  ({Assignment.left=current} '=' right=Expression)?
;

SelectionExpression returns Expression:
  TerminalExpression 
  (
    {MemberSelection.receiver=current} '.' 
    member=[Member]
    (methodinvocation?='(' 
      (args+=Expression (',' args+=Expression)*)? ')' )?
  )*
;

TerminalExpression returns Expression:
   {StringConstant} value=STRING |
   {IntConstant} value=INT |
   {BoolConstant} value = ('true' | 'false') |
   {This} 'this' |
   {Super} 'super' |
   {Null} 'null' |
   {SymbolRef} symbol=[Symbol] |
   '(' Expression ')'; 
