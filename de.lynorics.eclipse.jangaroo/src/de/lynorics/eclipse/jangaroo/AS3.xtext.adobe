/*
 * Copyright 2013
 *
 * Licensed under the Eclipse Public License version 1.0, available at
 * http://opensource.org/licenses/eclipse-1.0.txt
 */
grammar de.lynorics.eclipse.jangaroo.AS3 with org.eclipse.xtext.common.Terminals 

generate aS3 "http://www.lynorics.de/eclipse/jangaroo/AS3"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model hidden(WS, ML_COMMENT, SL_COMMENT):
    packageDecl
    block+=packageBlockEntry*
  ;

packageDecl
  : PACKAGE ident=identifier?
    pblock=packageBlock
  ;

packageBlock
  : LCURLY
    block+=packageBlockEntry*
    RCURLY
  ;

packageBlockEntry
  : ( importDefinition
    | annos=annotations
      mods=modifiers
      ( class=classDefinition
      | interface=interfaceDefinition
      | pbevar=variableDefinition
      | pbemethod=methodDefinition
      | namespace=namespaceDefinition
      | use=useNamespaceDirective
      )
    | SEMI
    )
  ;


importDefinition
  : IMPORT identifierStar SEMI
  ;

classDefinition
  : CLASS name=identi
    class=classExtendsClause
    implements=implementsClause
    block=typeBlock
  ;

interfaceDefinition
  : 
    INTERFACE name=identi
    interface=interfaceExtendsClause
    block=typeBlock
  ;

classExtendsClause
  : (EXTENDS extends+=identifier)?
  ;
interfaceExtendsClause
  : (EXTENDS extends+=identifier ( COMMA extends+=identifier)*)?
  ;
implementsClause
  : (IMPLEMENTS implements+=identifier ( COMMA implements+=identifier)*)?
  ;
typeBlock 
  : LCURLY
    block+=typeBlockEntry*
    RCURLY
  ;

typeBlockEntry
  : a=annotations 
    m=modifiers 
    ( var=variableDefinition
    | method=methodDefinition
    )
  | importDefinition
//  | includeDirective  This is in 'annos' instead
  ;

includeDirective
  : 'include'
    STRING
    SEMI
  ;


methodDefinition
  : 
    FUNCTION
    r=optionalAccessorRole  
    name=identi
    params=parameterDeclarationList
    type=typeExpression?
    (block=block|SEMI)
  ;

optionalAccessorRole
  : accessorRole?
  ;

accessorRole
  : GET | SET
  ;

namespaceDefinition
  : NAMESPACE name=identi
  ;

useNamespaceDirective
  : USE NAMESPACE identi SEMI
  ;

variableDefinition
  : decl=varOrConst vars+=variableDeclarator
    (COMMA vars+=variableDeclarator)*
    SEMI
  ;

varOrConst
  : VAR | CONST
  ;

variableDeclarator
  : identi type=typeExpression? var=variableInitializer?
  ;
declaration
  : varOrConst variableDeclarator
    tail=declarationTail
  ;

declarationTail
  : (COMMA var+=variableDeclarator)*
  ;

variableInitializer
  : ASSIGN expr=assignmentExpression
  ;

// A list of formal parameters
// TODO: shouldn't the 'rest' parameter only be allowed in the last position?
parameterDeclarationList
  : LPAREN
    ( params+=parameterDeclaration
      (COMMA params+=parameterDeclaration)*
    )?
    RPAREN
  ;


parameterDeclaration
  : basicParameterDeclaration | parameterRestDeclaration
  ;

basicParameterDeclaration
  : CONST? name=identi type=typeExpression? param=parameterDefault?
  ;

parameterDefault
  : ASSIGN assignmentExpression
  ;

parameterRestDeclaration
  : REST identi?
  ;
block
  : LCURLY blocks+=blockEntry* RCURLY
  ;

blockEntry
  :statement
  ;

condition
  : LPAREN expression RPAREN
  ;

statement
  : sb=block
  | sds=declarationStatement
  | ses=expressionStatement
  | sis=ifStatement
  // For statement
  | sfes=forEachStatement
  | sfs=forStatement

  // While statement
  | sws=whileStatement

  // do-while statement
  | sdws=doWhileStatement
  
  // with statement
  | ws=withStatement
  
  // switch statement
  | sss=switchStatement
  
  // get out of a loop (or switch)
  | sbs=breakStatement

  // do next iteration of a loop
  | scs=continueStatement

  // Return an expression
  | srs=returnStatement

  // throw an exception
  | sts=throwStatement
  
  // handle exceptions
  | ts=tryStatement
  
  // handle 'default xml namespace = "foo"'
  | sdxns=defaultXMLNamespaceStatement

  // empty statement
  | SEMI
  ;

declarationStatement
  : declaration SEMI
  ;

expressionStatement
  : expressionList SEMI
  ;
  
ifStatement
  : IF cond=condition statement=statement
    ((ELSE)=>elseClause)?
  ;

elseClause
  : ELSE statement
  ;

throwStatement
  : THROW expression SEMI
  ;

tryStatement
  : TRY
    block=block
  ( finally=finallyBlock
  | catch+=catchBlock+
    finally=finallyBlock?
  )
  ;

catchBlock
  : CATCH LPAREN identi type=typeExpression? RPAREN
    block=block
  ;

finallyBlock
  : FINALLY block
  ;

returnStatement
  : RETURN expression? SEMI
  ;
    
continueStatement
  : CONTINUE SEMI
  ;

breakStatement
  : BREAK SEMI
  ;

switchStatement
  : SWITCH condition
    switch=switchBlock
  ;

switchBlock
  : LCURLY
    (case+=caseStatement)*
    (def=defaultStatement)?
    RCURLY
  ;

caseStatement
  : CASE expression COLON l=switchStatementList
  ;
  
defaultStatement
  : DEFAULT COLON l=switchStatementList
  ;

switchStatementList
  : statements+=statement*
  ;

forEachStatement
  : f=FOR EACH
    LPAREN
    fesfor=forInClause
    RPAREN
    fes=statement
  ;

forStatement
  : f=FOR
    LPAREN
    ( forInClause RPAREN fsstate=statement

    | traditionalForClause RPAREN fsstate=statement
    )
  ;

traditionalForClause
  : a=forInit SEMI // initializer
    b=forCond SEMI // condition test
    c=forIter  // updater
  ;

forInClause
  : ficdecl=forInClauseDecl IN fictail=forInClauseTail
  ;

forInClauseDecl
  : declaration | identi
  ;


forInClauseTail
  : expressionList
  ;

// The initializer for a for loop
forInit
  : (declaration | expressionList )?
  ;

forCond
  : expressionList?
  ;

forIter
  : fiexpr=expressionList?
  ;

whileStatement
  : WHILE cond=condition statement=statement
  ;

doWhileStatement
  : DO state=statement WHILE cond=condition SEMI
  ;

withStatement
  : WITH cond=condition statement=statement
  ;

defaultXMLNamespaceStatement
  : DEFAULT XML NAMESPACE ASSIGN expression SEMI
  ;

typeExpression
  : c=COLON
    // TODO: identifier allows namespaces, and I suspect a type:spec shouldn't
    (identi=identifier | VOID | STAR)
  ; 

identifier 
  : (   qualifiedIdent
    )
    (poi=propOrIdent
    )*
  ;

propertyIdentifier
  : STAR
  | identi
  ;

qualifier
  : ( propertyIdentifier | reservedNamespace )
  ;

simpleQualifiedIdentifier
  : propertyIdentifier
  | qualifier DBL_COLON
    ( piden=propertyIdentifier
    |   bra=brackets
    )
  ;

expressionQualifiedIdentifier
  : encapsulatedExpression DBL_COLON
    ( pden=propertyIdentifier
    | bra=brackets
    )
  ;

nonAttributeQualifiedIdentifier
  : simpleQualifiedIdentifier
  | expressionQualifiedIdentifier
  ;

qualifiedIdentifier
  : e4xAttributeIdentifier
  | nonAttributeQualifiedIdentifier
  ;

qualifiedIdent
  : (namespaceName DBL_COLON)? identi 
  ;

namespaceName
  : IDENT | reservedNamespace
  ;

reservedNamespace
  : PUBLIC
  | PRIVATE
  | PROTECTED
  | INTERNAL
  ;

identifierStar
  : idents+=identi
    ( DOT idents+=identi
    )* 
    ( DOT STAR
    )?
  ;

annotations
  : ( anno+=annotation
    | include+=includeDirective
    )*
  ;

annotation
  : LBRACK
    identi
    params=annotationParamList?
    RBRACK
  ;

annotationParamList
  :
    LPAREN
    ( annos+=annotationParam
      (COMMA annos+=annotationParam)*
    )?
    RPAREN
  ;

annotationParam
  :
    identi ASSIGN const=constant
  | constant
  | identi
  ;

modifiers
  : mod+=modifier*
  ;

modifier
  : namespaceName
  | STATIC
  | FINAL
  | 'enumerable'
  | 'explicit'
  | OVERRIDE
  | DYNAMIC
  | 'intrinsic'
  ;

arguments
  : LPAREN expressionList RPAREN
  | LPAREN RPAREN
  ;
// This is an initializer used to set up an array.
arrayLiteral
  : LBRACK elementList? RBRACK
  ;
    
elementList
  : COMMA
  | nonemptyElementList
  ;
nonemptyElementList
  : assignmentExpression (COMMA expr+=assignmentExpression)*
  ;

element
  : assignmentExpression
  ;

// This is an initializer used to set up an object.
objectLiteral
  : LCURLY fieldList? RCURLY
  ;
  
fieldList
  : literalField (COMMA fields+=literalField?)*
  ;
  
literalField 
  :   fieldName COLON el=element
  ;
  
fieldName
  : identi
  | number
  ;

// the mother of all expressions
expression
  : assignmentExpression
  ;

// This is a list of expressions.
expressionList
  : expr+=assignmentExpression (COMMA expr+=assignmentExpression)*
  ;

// assignment expression (level 13)
assignmentExpression
  : conditionalExpression
  op+=assignmentOperator*
  ;

assignmentOperator
  : ASSIGN
  |   STAR_ASSIGN
  | DIV_ASSIGN
  | MOD_ASSIGN
  | PLUS_ASSIGN
  | MINUS_ASSIGN
  | SL_ASSIGN
  | SR_ASSIGN
  | BSR_ASSIGN
  | BAND_ASSIGN
  | BXOR_ASSIGN
  | BOR_ASSIGN
  | LAND_ASSIGN
  | LOR_ASSIGN
  ;

// conditional test (level 12)
conditionalExpression
  : logicalOrExpression
    (
      QUESTION
      cond=conditionalSubExpression
    )?
  ;
conditionalSubExpression
  : expr1=assignmentExpression COLON expr2=assignmentExpression
  ;

// TODO: should 'and'/'or' have same precidence as '&&'/'||' ?

// logical or (||)  (level 11)
logicalOrExpression
  : expr+=logicalAndExpression
    (o+=logicalOrOperator expr+=logicalAndExpression)*
  ;

logicalOrOperator
  : LOR | 'or'
  ;

// logical and (&&)  (level 10)
logicalAndExpression
  : expr+=bitwiseOrExpression
    (o+=logicalAndOperator expr+=bitwiseOrExpression)*
  ;

logicalAndOperator
  : LAND | 'and'
  ;

// bitwise or non-short-circuiting or (|)  (level 9)
bitwiseOrExpression
  : expr+=bitwiseXorExpression
    (o+=BOR expr+=bitwiseXorExpression)*
  ;

// exclusive or (^)  (level 8)
bitwiseXorExpression
  : expr+=bitwiseAndExpression
    (o+=BXOR expr+=bitwiseAndExpression)*
  ;

// bitwise or non-short-circuiting and (&)  (level 7)
bitwiseAndExpression
  : expr+=equalityExpression
    (o+=BAND expr+=equalityExpression)*
  ;

// equality/inequality (==/!=) (level 6)
equalityExpression
  : expr+=relationalExpression
  ( o+=equalityOperator
    expr+=relationalExpression
  )*
  ;

equalityOperator
  : STRICT_EQUAL | STRICT_NOT_EQUAL | NOT_EQUAL | EQUAL
  ;
  
// boolean relational expressions (level 5)
relationalExpression
  : expr+=shiftExpression
    (o+=relationalOperator expr+=shiftExpression)*
  ;

relationalOperator
  : IN
  | LT | GT | LE | GE | IS | AS | INSTANCEOF
  ;

// bit shift expressions (level 4)
shiftExpression
  : expr+=additiveExpression
    (o+=shiftOperator expr+=additiveExpression)*
  ;

shiftOperator
  : SL | SR | BSR
  ;

// binary addition/subtraction (level 3)
additiveExpression
  : expr+=multiplicativeExpression
    (o+=additiveOperator expr+=multiplicativeExpression)*
  ;

additiveOperator
  : PLUS | MINUS
  ;

// multiplication/division/modulo (level 2)
multiplicativeExpression
  : expr+=unaryExpression
    ( o+=multiplicativeOperator
      expr+=unaryExpression
    )*
  ;

multiplicativeOperator
  : s=STAR
  | DIV
  | MOD
  ;

//  (level 1)
unaryExpression
  : in=INC expr=unaryExpression
  | de=DEC expr=unaryExpression
  | MINUS uaem=unaryExpression
  | PLUS uaep=unaryExpression
  | uaenpm=unaryExpressionNotPlusMinus
  ;

unaryExpressionNotPlusMinus
  : DELETE postfixExpression
  | VOID unaryExpression
  | TYPEOF unaryExpression
  | LNOT unaryExpression
  | BNOT unaryExpression
  | postfixExpression
  ;

// qualified names, array expressions, method invocation, post inc/dec
postfixExpression
  : {postfixExpression}
    (peexpr=primaryExpression
     pepoi=propOrIdent
    | LBRACK expr=expression rb=RBRACK
    | E4X_DESC pewi=qualifiedIdentifier 
    | DOT LPAREN expr=expression RPAREN
    | d=DOT e4x=e4xAttributeIdentifier
    | d=DOT STAR
    | args+=arguments*
    (   in=INC
    | de=DEC
    )?
  );


e4xAttributeIdentifier
  : E4X_ATTRI
    ( qualifiedIdent
    | STAR
    | LBRACK expression RBRACK
    )
  ;

primaryExpression
  : UNDEFINED
  | constant
  | arrayLiteral
  | objectLiteral
  | functionExpression
  | newExpression
  | encapsulatedExpression
  | e4xAttributeIdentifier
  | qualifiedIdent
  ;


propOrIdent
  : 
    d=DOT propId=qualifiedIdent
  ;

constant
  : xmlLiteral
  | regexpLiteral
  | number
  | STRING
  | TRUE
  | FALSE
  | NULL
  ;

number  : HEX_LITERAL
  | INT
  | OCTAL
  | FLOAT
  ;

  
xmlLiteral
  : // We have to have the LT in the outer grammar for lookahead
    // in AS3Parser to be able to predict that the xmlLiteral rule
    // should be used.
    LT
  ;

regexpLiteral
  : s=DIV
  ;

newExpression
  : NEW fullNewSubexpression args+=arguments?
  ;

fullNewSubexpression
  : ( expr+=primaryExpression
    )
    ( fnsd+=DOT quali+=qualifiedIdent
    | brack+=brackets
    )*
  ;

propertyOperator
  : DOT qualifiedIdent
  | brackets
  ;

brackets
  : LBRACK expressionList RBRACK
  ;

encapsulatedExpression
  : LPAREN assignmentExpression RPAREN
  ;

functionSignature
  : param=parameterDeclarationList expr=typeExpression?
  ;

// TODO: block should be optional here,
functionCommon
  : sig=functionSignature block=block
  ;

functionExpression
  : FUNCTION name=IDENT? func=functionCommon
  ;


identi
  : IDENT
  | i=USE 
  | i=XML
  | i=DYNAMIC
  | i=NAMESPACE
  | i=IS
  | i=AS
  | i=GET
  | i=SET
  ;

IDENT:
  ID ('.' ID)*
;

PACKAGE   : 'package';
PUBLIC    : 'public';
PRIVATE   : 'private';
PROTECTED : 'protected';
INTERNAL  : 'internal';
OVERRIDE  : 'override';
FUNCTION  : 'function';
EXTENDS   : 'extends';
IMPLEMENTS  : 'implements';
VAR   : 'var';
STATIC    : 'static';
IF    : 'if';
IMPORT    : 'import';
FOR   : 'for';
EACH    : 'each';
IN    : 'in';
WHILE   : 'while';
DO    : 'do';
SWITCH    : 'switch';
CASE    : 'case';
DEFAULT   : 'default';
ELSE    : 'else';
CONST   : 'const';
CLASS   : 'class';
INTERFACE : 'interface';
TRUE    : 'true';
FALSE   : 'false';
DYNAMIC   : 'dynamic';
USE   : 'use';
XML   : 'xml';
NAMESPACE : 'namespace';
IS    : 'is';
AS    : 'as';
GET   : 'get';
SET   : 'set';
WITH    : 'with';
RETURN    : 'return';
CONTINUE  : 'continue';
BREAK   : 'break';
NULL    : 'null';
NEW   : 'new';
INSTANCEOF  : 'instanceof';
DELETE    : 'delete';
VOID    : 'void';
TYPEOF    : 'typeof';
TRY   : 'try';
CATCH   : 'catch';
FINALLY   : 'finally';
UNDEFINED : 'undefined';
THROW   : 'throw';
FINAL   : 'final';

// OPERATORS
QUESTION    : '?' ;
LPAREN      : '(' ;
RPAREN      : ')' ;
LBRACK      : '[' ;
RBRACK      : ']' ;
LCURLY      : '{' ;
RCURLY      : '}' ;
COLON     : ':' ;
DBL_COLON   : '::'  ;
COMMA     : ',' ;
ASSIGN      : '=' ;
EQUAL     : '=='  ;
STRICT_EQUAL    : '===' ;
LNOT      : '!' ;
BNOT      : '~' ;
NOT_EQUAL   : '!='  ;
STRICT_NOT_EQUAL  : '!==' ;
DIV     : '/' ;
DIV_ASSIGN    : '/='  ;
PLUS      : '+' ;
PLUS_ASSIGN   : '+='  ;
INC     : '++'  ;
MINUS     : '-' ;
MINUS_ASSIGN    : '-='  ;
DEC     : '--'  ;
STAR      : '*' ;
STAR_ASSIGN   : '*='  ;
MOD     : '%' ;
MOD_ASSIGN    : '%='  ;
SR      : '>>'  ;
SR_ASSIGN   : '>>=' ;
BSR     : '>>>' ;
BSR_ASSIGN    : '>>>='  ;
GE      : '>='  ;
GT      : '>' ;
SL      : '<<'  ;
SL_ASSIGN   : '<<=' ;
LE      : '<='  ;
LT      : '<' ;
BXOR      : '^' ;
BXOR_ASSIGN   : '^='  ;
BOR     : '|' ;
BOR_ASSIGN    : '|='  ;
LOR     : '||'  ;
BAND      : '&' ;
BAND_ASSIGN   : '&='  ;
LAND      : '&&'  ;
LAND_ASSIGN   : '&&=' ;
LOR_ASSIGN    : '||=' ;
E4X_ATTRI   : '@' ; 
SEMI      : ';' ;


DOT   : '.' ;
E4X_DESC  : '..'  ;
REST    : '...' ;

HEX_LITERAL : '0' ('x'|'X') HEX_DIGIT+ ;

terminal STRING : 
      '"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
      "'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
    ; 

terminal OCTAL:
  '0' ('0'..'7')+
;

terminal FLOAT returns ecore::EBigDecimal:
  ('0'..'9')* '.' ('0'..'9')+;

terminal HEX_DIGIT
  : ('0'..'9'|'A'..'F'|'a'..'f')
  ;

