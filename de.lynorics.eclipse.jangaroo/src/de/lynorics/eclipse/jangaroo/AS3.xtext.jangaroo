/*
 * Copyright 2013
 *
 * Licensed under the Eclipse Public License version 1.0, available at
 * http://opensource.org/licenses/eclipse-1.0.txt
 */
grammar de.lynorics.eclipse.jangaroo.AS3 with de.lynorics.eclipse.jangaroo.AS3Terminals

generate aS3 "http://www.lynorics.de/eclipse/jangaroo/AS3"

as3CompilationUnit
  : packageDecl
    packageBlocks+=packageBlockEntry*
  ;

packageDecl
  : PACKAGE identifier=identifier?
    packageBlock=packageBlock
  ;

packageBlock
  : {packageBlock}
    LCURLY
    packageBlockEntries+=packageBlockEntry*
    RCURLY
    //-> (BLOCK packageBlockEntry*)
  ;



packageBlockEntry:
   {packageBlockEntry}( importDefinition=importDefinition
//    | includeDirective  This is in 'annos' instead
      ( classDefinition=classDefinition
      | interfaceDefinition=interfaceDefinition
      | variableDefinition
      | methodDefinition
      | namespaceDefinition
      | useNamespaceDirective
      )
    | SEMI
//    | statement
    )
  ;

importDefinition
  : IMPORT identifierStar SEMI
  ;

/* semi
  : {semi}
     SEMI!
//  | { virtualSemi() }?
  ;*/ 

classDefinition
  : CLASS ident
    classExtendsClause
    implementsClause
    typeBlock
  ;

as2ClassDefinition
  : CLASS identifier
    classExtendsClause
    implementsClause
    typeBlock
  ;

interfaceDefinition
  : 
    INTERFACE ident
    interfaceExtendsClause
    typeBlock
  ;

as2InterfaceDefinition
  : INTERFACE identifier
    interfaceExtendsClause
    typeBlock
  ;

classExtendsClause
  : {classExtendsClause}(EXTENDS identifier)?
  ;
interfaceExtendsClause
  : {interfaceExtendsClause}(EXTENDS identifier ( COMMA identifier)*)?
  ;
implementsClause
  : {implementsClause}(IMPLEMENTS identifier ( COMMA identifier)*)?
  ;
typeBlock
  : {typeBlock}LCURLY
    typeBlockEntry*
    RCURLY
  ;

typeBlockEntry
  : /*statement
  | (LBRACK)=>*/
    ( variableDefinition
    | methodDefinition
    )
  | importDefinition
  | as2IncludeDirective
//  | includeDirective  This is in 'annos' instead
  ;

as2IncludeDirective
  : INCLUDE_DIRECTIVE
    STRING_LITERAL
  ;

includeDirective
  : 'include'
    STRING_LITERAL
    SEMI
  ;


methodDefinition
  : 
    FUNCTION
    ident
    parameterDeclarationList
    typeExpression?
    (block|semi)
  ;

optionalAccessorRole
  : accessorRole?
  ;

accessorRole
  : GET | SET
  ;

namespaceDefinition
  : NAMESPACE ident
  ;

useNamespaceDirective
  : USE NAMESPACE ident SEMI
  ;



varOrConst
  : VAR | CONST
  ;


  ;
declaration
  : varOrConst variableDeclarator
    declarationTail
  ;

declarationTail
  : {declarationTail}(COMMA variableDeclarator)*
  ;



// A list of formal parameters
// TODO: shouldn't the 'rest' parameter only be allowed in the last position?
parameterDeclarationList
  : {parameterDeclarationList}LPAREN
    ( parameterDeclaration
      (COMMA parameterDeclaration+=parameterDeclaration)*
    )?
    RPAREN
  ;


parameterDeclaration
  : basicParameterDeclaration | parameterRestDeclaration
  ;

basicParameterDeclaration
  : CONST? ident typeExpression? parameterDefault?
  ;

parameterDefault
    // TODO: can we be more strict about allowed values?
  : ASSIGN assignmentExpression
  ;

parameterRestDeclaration
  : REST ident?
  ;
block
  : LCURLY blockEntry* RCURLY
  ;

blockEntry
  :
/*options { k=*; }
  : a=annotations! { placeholder($a.tree); }
    m=modifiers!
    ( variableDefinition[$a.tree,$m.tree]
    | methodDefinition[$a.tree,$m.tree]
    )
  |*/ statement
  ;

condition
  : LPAREN expression RPAREN
  ;

statement
  : (LCURLY)=> block
  | declarationStatement
  | expressionStatement
  | ifStatement
  // For statement
  | forEachStatement
  | forStatement

  // While statement
  | whileStatement

  // do-while statement
  | doWhileStatement
  
  // with statement
  | withStatement
  
  // switch statement
  | switchStatement
  
  // get out of a loop (or switch)
  | breakStatement

  // do next iteration of a loop
  | continueStatement

  // Return an expression
  | returnStatement

  // throw an exception
  | throwStatement
  
  // handle exceptions
  | tryStatement
  
  // handle 'default xml namespace = "foo"'
  | defaultXMLNamespaceStatement

  // empty statement
  | SEMI!
  ;

declarationStatement
  : declaration SEMI
  ;

expressionStatement
  : expressionList SEMI
  ;
  
ifStatement
  : IF condition statement
    ((ELSE)=>elseClause)?
  ;

elseClause
  : ELSE statement
  ;

throwStatement
  : THROW expression SEMI!
  ;

tryStatement
  : TRY
    block
  ( finallyBlock
  | catchBlock+
    finallyBlock?
  )
  ;

catchBlock
  : CATCH LPAREN ident typeExpression? RPAREN
    block
  ;

finallyBlock
  : FINALLY block
  ;

returnStatement
  : RETURN expression? SEMI
  ;
    
continueStatement
  : CONTINUE SEMI
  ;

breakStatement
  : BREAK SEMI
  ;

switchStatement
  : SWITCH condition
    switchBlock
  ;

switchBlock
  : LCURLY
    (caseStatement)*
    (defaultStatement)?
    RCURLY
  ;

caseStatement
  : CASE expression COLON! l=switchStatementList
  ;
  
defaultStatement
  : DEFAULT COLON! l=switchStatementList
  ;

switchStatementList
  : statement*
  ;

forEachStatement
  : f=FOR EACH
    LPAREN
    forInClause
    RPAREN
    statement
  ;

forStatement
  : f=FOR
    LPAREN
    ( (forInClauseDecl IN)=>forInClause RPAREN statement

    | traditionalForClause RPAREN statement
    )
  ;

traditionalForClause
  : a=forInit SEMI! // initializer
    b=forCond SEMI! // condition test
    c=forIter   // updater
  ;

forInClause
  : forInClauseDecl IN! forInClauseTail
  ;

forInClauseDecl
  : declaration | ident
  ;


forInClauseTail
  : expressionList
  ;

// The initializer for a for loop
forInit 
  : (declaration | expressionList )?
  ;

forCond
  : expressionList?
  ;

forIter
  : expressionList?
  ;

whileStatement
  : WHILE condition statement
  ;

doWhileStatement
  : DO statement WHILE! condition semi
  ;

withStatement
  : WITH condition statement
  ;

defaultXMLNamespaceStatement
  : DEFAULT XML NAMESPACE ASSIGN expression semi
  ;





propertyIdentifier
  : STAR
  | ident
  ;

qualifier
  : ( propertyIdentifier | reservedNamespace )
  ;

simpleQualifiedIdentifier
  : propertyIdentifier
  | qualifier DBL_COLON
    ( propertyIdentifier
    |   brackets
    )
  ;

expressionQualifiedIdentifier
  : encapsulatedExpression DBL_COLON
    ( propertyIdentifier
    | brackets
    )
  ;

nonAttributeQualifiedIdentifier
  : simpleQualifiedIdentifier
  | expressionQualifiedIdentifier
  ;

qualifiedIdentifier
  : e4xAttributeIdentifier
  | nonAttributeQualifiedIdentifier
  ;

qualifiedIdent
  : (namespaceName DBL_COLON)? ident 
  ;

namespaceName
  : IDENT | reservedNamespace
  ;

reservedNamespace
  : PUBLIC
  | PRIVATE
  | PROTECTED
  | INTERNAL
  ;

identifierStar
  : ident
    ( options
    : DOT ident
    )* 
    ( DOT STAR
    )?
  ;

annotations
  : ( annotation
    | includeDirective
    )*
  ;

annotation
  : LBRACK
    ident
    annotationParamList?
    RBRACK
  ;

annotationParamList
  :
    LPAREN
    ( annotationParam
      (COMMA annotationParam)*
    )?
    RPAREN
  ;

/*
[Inspectable(name="Icon Offset", verbose = 1,type=Boolean, defaultValue=true)]
[Inspectable(defaultValue="circular")]
[Bindable]
[ChangeEvent("event")]
[Inspectable("danger", 1, true, maybe)] 
[InspectableList("flavorStr","colorStr")]
[Event("click")]
[Collection (name="name", variable="varname", collectionClass="mx.utils.CollectionImpl", collectionItem="coll-item-classname", identifier="string")] 
*/

annotationParam
  :
    ident ASSIGN constant
  | constant
  | ident
  ;

modifiers
  : modifier*
  ;

modifier
  : namespaceName
  | STATIC
  | FINAL
  | 'enumerable'
  | 'explicit'
  | OVERRIDE
  | DYNAMIC
  | 'intrinsic'
  ;

arguments
  : LPAREN expressionList RPAREN
  | LPAREN RPAREN
  ;
// This is an initializer used to set up an array.
arrayLiteral
  : LBRACK elementList? RBRACK
  ;
    
elementList
  : COMMA!
  | nonemptyElementList
  ;
nonemptyElementList
  : assignmentExpression (COMMA! assignmentExpression)*
  ;

element
  : assignmentExpression
  ;

// This is an initializer used to set up an object.
objectLiteral
  : LCURLY fieldList? RCURLY
  ;
  
fieldList
  : literalField (COMMA! literalField?)*
  ;
  
literalField 
  :   fieldName COLON element
  ;
  
fieldName
  : ident
  | number
  ;




variableDefinition
  : {variableDefinition}
    (COMMA variableDeclarator+=variableDeclarator)*
    SEMI
  ;

variableDeclarator
  : IDENTIF typeExpression? variableInitializer?;
  
variableInitializer
  : ASSIGN assignmentExpression
  ;

typeExpression
  : c=COLON
    // TODO: identifier allows namespaces, and I suspect a type:spec shouldn't
    (identifier | VOID | STAR)
  ;

identifier 
  : (   qualifiedIdent
    )
    ( options
    :   poi+=propOrIdent
    )*
  ;

propOrIdent
  : 
    d=DOT propId=qualifiedIdent
    /* without further semantic analysis, we can't
       tell if a.b is an access of the property 'b'
       from the var 'a' or a reference to the type
       'b' in the package 'a'.  (This could be
       resolved in an AST post-processing step) */
  ;

