/*
 * Copyright 2013
 *
 * Licensed under the Eclipse Public License version 1.0, available at
 * http://opensource.org/licenses/eclipse-1.0.txt
 */
/*
* generated by Xtext
*/
package de.lynorics.eclipse.jangaroo.ui.quickfix

import com.google.inject.Inject
import de.lynorics.eclipse.jangaroo.ui.contentassist.InsertImportCommand
import de.lynorics.eclipse.jangaroo.validation.AS3Validator
import org.eclipse.emf.ecore.EObject
import org.eclipse.jface.text.IDocument
import org.eclipse.xtext.builder.builderState.EObjectDescription
import org.eclipse.xtext.diagnostics.Diagnostic
import org.eclipse.xtext.ui.editor.model.edit.IModificationContext
import org.eclipse.xtext.ui.editor.model.edit.ISemanticModification
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider
import org.eclipse.xtext.ui.editor.quickfix.Fix
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
import org.eclipse.xtext.ui.search.IXtextEObjectSearch
import org.eclipse.xtext.validation.Issue

/**
 * Custom quickfixes.
 *
 * see http://www.eclipse.org/Xtext/documentation.html#quickfixes
 */
class AS3QuickfixProvider extends DefaultQuickfixProvider {


  @Inject
  IXtextEObjectSearch  iXtextEObjectSearch ;

  @Fix(AS3Validator::CLASS_SHOULD_START_WITH_CAPITAL_LETTER)
  def capitalizeClass(Issue issue, IssueResolutionAcceptor acceptor) {
    acceptor.accept(issue, 'Capitalize name', 'Capitalize the name.', 'upcase.png') [
      context |
      val xtextDocument = context.xtextDocument
      val firstLetter = xtextDocument.get(issue.offset, 1)
      xtextDocument.replace(issue.offset, 1, firstLetter.toUpperCase)
    ]
  }

  @Fix(AS3Validator::INTERFACE_SHOULD_START_WITH_CAPITAL_LETTER)
  def capitalizeInterface(Issue issue, IssueResolutionAcceptor acceptor) {
    acceptor.accept(issue, 'Capitalize name', 'Capitalize the name.', 'upcase.png') [
      context |
      val xtextDocument = context.xtextDocument
      val firstLetter = xtextDocument.get(issue.offset, 1)
      xtextDocument.replace(issue.offset, 1, firstLetter.toUpperCase)
    ]
  }

  @Fix(AS3Validator::METHOD_SHOULD_START_WITH_LOWERCASE)
  def lowercaseMethod(Issue issue, IssueResolutionAcceptor acceptor) {
    acceptor.accept(issue, 'Lowercase name', 'Lowercase the name.', 'upcase.png') [
      context |
      val xtextDocument = context.xtextDocument
      val firstLetter = xtextDocument.get(issue.offset, 1)
      xtextDocument.replace(issue.offset, 1, firstLetter.toLowerCase)
    ]
  }

  @Fix(AS3Validator::VARIABLE_SHOULD_START_WITH_LOWERCASE)
  def lowercaseVariable(Issue issue, IssueResolutionAcceptor acceptor) {
    acceptor.accept(issue, 'Lowercase name', 'Lowercase the name.', 'upcase.png') [
      context |
      val xtextDocument = context.xtextDocument
      val firstLetter = xtextDocument.get(issue.offset, 1)
      xtextDocument.replace(issue.offset, 1, firstLetter.toLowerCase)
    ]
  }

// TODO handle every part of the package name
  @Fix(AS3Validator::PACKAGE_SHOULD_START_WITH_LOWERCASE)
  def lowercasePackage(Issue issue, IssueResolutionAcceptor acceptor) {
    acceptor.accept(issue, 'Lowercase name', 'Lowercase the name.', 'upcase.png') [
      context |
      val xtextDocument = context.xtextDocument
      val firstLetter = xtextDocument.get(issue.offset, 1)
      xtextDocument.replace(issue.offset, 1, firstLetter.toLowerCase)
    ]
  }

    @Fix(Diagnostic.LINKING_DIAGNOSTIC)
    def handleMissingLink(Issue issue, IssueResolutionAcceptor acceptor) {
        if (issue.getMessage().startsWith("Couldn't resolve reference to EObject '")) {
        	var String objectName = issue.getMessage().split("'").get(2);
			importMissingInterface(issue, acceptor,objectName);
			importMissingClass(issue, acceptor,objectName);
        }
        createLinkingIssueResolutions(issue, acceptor);
    }
	
	private def importMissingInterface(Issue issue, IssueResolutionAcceptor acceptor, String objectName) {
		iXtextEObjectSearch.findMatches(objectName, "Interface").forEach[
			descriptor |
			val String qName = (descriptor as EObjectDescription).qualifiedName.toString;    
			if (qName.endsWith(objectName)) {
				acceptor.accept(issue,
					"Import "+qName, // label
					"Import "+qName, // description
					"outline-import.gif", // icon
					new ISemanticModification() {
						override apply(EObject element, IModificationContext context) throws Exception {
								var InsertImportCommand command = new InsertImportCommand();
								var int importOffset = command.getImportOffset(element, qName);
								command.apply(context.xtextDocument as IDocument, importOffset, qName);
						}
					}
				);
			}
		]
	}
	
	private def importMissingClass(Issue issue, IssueResolutionAcceptor acceptor, String objectName) {
		iXtextEObjectSearch.findMatches(objectName, "Class").forEach[
			descriptor |
			val String qName = (descriptor as EObjectDescription).qualifiedName.toString;    
			if (qName.endsWith(objectName)) {
				acceptor.accept(issue,
					"Import "+qName, // label
					"Import "+qName, // description
					"outline-import.gif", // icon
					new ISemanticModification() {
						override apply(EObject element, IModificationContext context) throws Exception {
							var InsertImportCommand command = new InsertImportCommand();
							var int importOffset = command.getImportOffset(element, qName);
							command.apply(context.xtextDocument as IDocument, importOffset, qName);
						}
					}
				);
			}
		]
	}
	
}
